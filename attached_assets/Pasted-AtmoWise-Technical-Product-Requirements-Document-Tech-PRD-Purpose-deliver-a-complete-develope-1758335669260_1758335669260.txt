AtmoWise — Technical Product Requirements Document (Tech PRD)

Purpose: deliver a complete, developer-focused PRD so your team can start building AtmoWise immediately. This document focuses only on the technical product requirements, architecture, data model, APIs, prompts, dev tasks, QA, and deployment details. It assumes a web app (mobile-first) built with Next.js + Tailwind, Supabase, and an LLM (OpenRouter).

⸻

1) Executive summary (one paragraph)

AtmoWise is a mobile-first web application that converts public air quality and environmental data into personalized, actionable lung-health guidance. The technical MVP integrates air quality APIs, a user sensitivity profile, symptom logging, an LLM for empathetic contextualization, and a Supabase backend to persist data and seed advice/resources. The goal of the build is a demo-ready, production-style prototype that is reliable with graceful fallbacks.

⸻

2) Objectives & success metrics

Primary objectives
	•	Demonstrate a working, honest link between environmental exposure and personalized guidance.
	•	Deliver a polished mobile UX that judges can use on their phone.
	•	Show technical rigor: live external API integration, LLM integration, persistent DB, charts.

Success metrics for hackathon
	•	Live air data fetch + normalized display on dashboard (Risk Card) — visible on demo.
	•	LLM reflections show contextual outputs for symptom notes.
	•	Timeline chart plotting air vs symptom entries (demo data allowed).
	•	App runs without major errors during demo; emergency flow present.
	•	Clear privacy stance (no PII unless opt-in).

Optional judge / scoring goals
	•	Score ≥4/5 on Technical Rigor, UX, Practicality, Originality (via polished demo, personalization, safety features).

⸻

3) Scope: MVP vs Stretch

MVP (must complete — targeted for 12 hours):
	1.	Here-and-Now Risk Card (real-time air data + simple status Good/Caution/Avoid)
	2.	Personal sensitivity profile (asthma/pregnancy/age) stored in Supabase
	3.	Symptom logging (text + severity) persisted to Supabase
	4.	LLM-driven Reflection (OpenRouter) on symptom entries — summary + action + severity tag
	5.	Exposure vs Symptom timeline (Chart.js) using API + symptom data (seeded)
	6.	Resource navigator + always-visible crisis button
	7.	Mobile-first responsive UI + deploy to Vercel

Stretch (if time allows):
	•	Saved Places (Home/Work/Gym) + one-tap check
	•	6–12 hour forecast & Run Coach suggestion window
	•	Indoor exposure tips, meteorological overlays (wind/humidity)
	•	Multilingual notification (translation API)
	•	Small analytic correlation demo (e.g., Pearson correlation of PM2.5 vs symptom severity)

⸻

4) User personas & primary user flows

Personas
	•	Student with Asthma (fast value from personalized thresholds)
	•	Concerned Resident (checks saved places)
	•	Clinician / Mentor (demo use: view exported report)

Primary flows
	1.	First-time user: Landing → Quick profile toggles (asthma / pregnancy / age group) → Dashboard risk card (auto geolocate OR manual entry)
	2.	Check risk: Dashboard shows current AQ + one-sentence rationale → action suggestions shown underneath
	3.	Log symptom: Enter text + slider severity → call LLM → show AI reflection & recommended action → persisted
	4.	View timeline: Chart shows pollutant trend + symptom bars → hover shows LLM notes
	5.	Emergency: Tap Crisis → immediate modal with hotline / campus clinic contact

⸻

5) Functional requirements (detailed)

Each functional requirement includes acceptance criteria.

FR1 — Dashboard Risk Card
	•	What: Shows current air metrics (PM2.5, PM10, O₃, NO₂ if available), a short status (Good / Caution / Avoid), and a one-sentence rationale.
	•	Acceptance: For a given coordinate, the app displays pollutant values and status in under 2s (if live API responds). If API missing AQI field, app uses provider AQI if available or fallback mapping (see implementation notes).
	•	Edge cases: If API fails, use cached last reading or demo seed; display “data cached / demo mode”.

FR2 — Sensitivity Profile
	•	What: Simple toggles (asthma, cardiopulmonary disease, pregnancy, child/older adult) + saved into Supabase.
	•	Acceptance: Changing toggles updates threshold logic immediately on front end and is persisted.

FR3 — Symptom Log
	•	What: Text entry + severity (1–5) + optional link to latest air_read. Stored with timestamp in Supabase.
	•	Acceptance: Submitting creates a symptom row and triggers LLM reflection; UI displays LLM response.

FR4 — LLM Reflection & Advice
	•	What: Send symptom text + context (AQI, sensitivity) to LLM. LLM must return JSON: {summary, action, severity}.
	•	Acceptance: App parses LLM JSON and displays summary + action; if severity === "high", app triggers emergency modal.

FR5 — Timeline Visualization
	•	What: Chart combining time series of pollutant (line) and symptom severity (bars/dots) for last N days.
	•	Acceptance: Chart renders with demo/real data; tooltips show details.

FR6 — Saved Places (optional)
	•	What: User pins places (name + lat/lon). One-tap check triggers lookup & shows risk card for that location.
	•	Acceptance: Saved places persist and can be rechecked quickly.

FR7 — Resource Navigator & Crisis Button
	•	What: A persistent bottom bar / floating button labeled “Get Help Now”: opens modal with campus clinic, national hotlines, and recommended action.
	•	Acceptance: Button visible on all routes; click shows contact options.

⸻

6) Non-functional requirements (NFR)
	•	Performance: Dashboard air lookup should complete within 2–4s under normal network. LLM response within 3–8s (expect variance).
	•	Availability: App must be deployable to Vercel; Supabase uptime assumed.
	•	Security: Environment variables in Vercel & Supabase secrets only. No API keys in frontend.
	•	Privacy: Default anonymous usage. No PII collected unless user explicitly registers. Data retention: symptom rows stored; include a quick delete option for user data in UI.
	•	Accessibility: WCAG AA basics: keyboard navigation, contrast ratio, alt text, labels.
	•	Scalability: Single-tenant MVP; DB normalized; cache air reads to avoid heavy API usage.
	•	Rate limiting: Graceful rate limit detection and fallback.

⸻

7) System architecture (component breakdown)
	•	Frontend (Next.js)
	•	Pages: / (landing), /dashboard, /profile, /log, /timeline, /resources
	•	Components: RiskCard, SymptomForm, LLMResponseCard, TimelineChart, SavedPlaces, CrisisModal
	•	State: React hooks + SWR for data fetching/cache
	•	API layer (Next.js API routes or small Node lambda)
	•	/api/air?lat=&lon= → fetch/normalize from OpenWeather/OpenAQ/AirNow; cache into Supabase air_reads.
	•	/api/llm/reflection → proxy call to OpenRouter (send prompt + context).
	•	Database (Supabase)
	•	Tables: users, profiles, air_reads, symptoms, tips, resources, saved_places
	•	LLM (OpenRouter)
	•	For empathetic reflection & contextual advice
	•	External APIs
	•	OpenWeather (Air Pollution & forecast) — primary
	•	OpenAQ — fallback
	•	AirNow — optional US fallback (requires key)
	•	Geocoding (OpenCage or Google Maps) — for saved places
	•	Deployment
	•	Frontend: Vercel
	•	DB: Supabase
	•	Keys stored in Vercel env & Supabase secrets

⸻

8) Data model & SQL (copy-paste)

Below are recommended Supabase SQL statements (Postgres) to create the main tables. Run these in Supabase SQL editor.

-- users (optional anonymous)
create table if not exists users (
  id uuid primary key default gen_random_uuid(),
  anon_id text,
  created_at timestamptz default now()
);

-- profiles
create table if not exists profiles (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references users(id) on delete cascade,
  display_name text,
  sensitivity jsonb, -- e.g. {"asthma": true, "pregnant": false, "age_group":"adult"}
  saved_places jsonb, -- array of {name, lat, lon}
  created_at timestamptz default now()
);

-- air_reads (cached external API results)
create table if not exists air_reads (
  id uuid primary key default gen_random_uuid(),
  lat double precision,
  lon double precision,
  source text, -- openaq/openweather/airnow
  timestamp timestamptz,
  pm25 double precision,
  pm10 double precision,
  o3 double precision,
  no2 double precision,
  aqi integer,
  raw_payload jsonb,
  created_at timestamptz default now()
);
create index if not exists idx_air_reads_coords on air_reads (lat, lon);

-- symptoms
create table if not exists symptoms (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references users(id) on delete set null,
  timestamp timestamptz default now(),
  label text,
  severity smallint, -- 1..5
  note text,
  ai_summary text,
  ai_action text,
  ai_severity text,
  linked_air_id uuid references air_reads(id),
  created_at timestamptz default now()
);

-- tips
create table if not exists tips (
  id uuid primary key default gen_random_uuid(),
  tag text,
  content text,
  created_at timestamptz default now()
);

-- resources
create table if not exists resources (
  id uuid primary key default gen_random_uuid(),
  title text,
  type text,
  tags text[],
  url text,
  phone text,
  created_at timestamptz default now()
);

-- saved_places (optional normalized)
create table if not exists saved_places (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references users(id) on delete cascade,
  name text,
  lat double precision,
  lon double precision,
  created_at timestamptz default now()
);


⸻

9) API integration details (calls, sample requests)

OpenWeather (Air Pollution) — recommended primary
	•	Current:

GET https://api.openweathermap.org/data/2.5/air_pollution?lat={lat}&lon={lon}&appid={API_KEY}

Response includes concentrations and an aqi field (per provider). Use provider AQI when present.

OpenAQ (global fallback)
	•	Latest measurements by coordinates:

GET https://api.openaq.org/v2/latest?coordinates={lat},{lon}&radius=10000&parameter=pm25,pm10,no2,o3



AirNow (US fallback — requires API KEY)
	•	Observation:

GET https://www.airnowapi.org/aq/observation/latLong/current?format=application/json&latitude={}&longitude={}&distance=25&API_KEY={}



Geocoding (OpenCage or Google)
	•	Use for address → lat/lon.

Implementation notes
	•	Always call external APIs from server-side (Next.js API route) to avoid leaking keys.
	•	Normalize result into a common object:

{
  lat, lon, source, timestamp, pm25, pm10, o3, no2, aqi, raw_payload
}


	•	Cache normalized result in air_reads for 10–30 minutes per coordinate (SWR + DB) to avoid rate limits.

⸻

10) LLM design: prompts, JSON contract & safety

Overall approach
	•	Use LLM strictly for empathetic reflection + contextual instructions. Do not ask LLM for diagnosis. Implement guardrails: system prompt instructs to never provide diagnoses and to escalate severe signals.

Prompt contract (system + user)
	•	System: You are a brief, supportive, safety-first health assistant. Do not diagnose. If the user indicates severe symptoms (e.g., “can’t breathe”, “chest pain”), respond with emergency instructions and set severity to “high”. Keep replies concise (max 2 sentences). Return JSON only.
	•	User: Provide {note, pm25, aqi, sensitivity}.

Expected JSON response (strict parseable)

{
  "summary": "You wrote xxxx. It sounds like ...",
  "action": "Short actionable advice (one line).",
  "severity": "low|moderate|high",
  "explainers": "Optional short rationale in one sentence (optional)."
}

Example prompt (string interpolation):

SYSTEM: You are a concise, empathetic health assistant. Never provide medical diagnoses. If text indicates emergency (can't breathe, chest pain, fainting), include 'seek immediate medical attention' and set severity to 'high'. Return only JSON: {"summary","action","severity","explainers"}.

USER: note="{user_note}", pm25={pm25}, aqi={aqi}, sensitivity={ "asthma": true, ... }

Safety actions
	•	If LLM returns severity === "high" → show emergency modal with a large visible phone number/button; do not rely on LLM accuracy — also run a keyword emergency regex (e.g., /can’t breathe|chest pain|faint|pass out/i) on raw note to override.

Fallback
	•	If LLM times out or errors: use a canned response mapping based on severity slider and AQI thresholds (predefined tips table).

⸻

11) Example Next.js API route (pseudocode)

/pages/api/air.js

import fetch from 'node-fetch';
import { supabaseAdmin } from '../../lib/supabaseAdmin';

export default async function handler(req, res) {
  const { lat, lon } = req.query;
  try {
    // 1) check cache in DB for recent entry within 10 minutes
    const { data: cache } = await supabaseAdmin
      .from('air_reads')
      .select('*')
      .eq('lat', lat)
      .eq('lon', lon)
      .order('timestamp', { ascending:false })
      .limit(1);

    const tenMinutes = 10 * 60 * 1000;
    if (cache && (Date.now() - new Date(cache[0].timestamp)) < tenMinutes) {
      return res.status(200).json(cache[0]);
    }

    // 2) call OpenWeather
    const owResp = await fetch(`https://api.openweathermap.org/data/2.5/air_pollution?lat=${lat}&lon=${lon}&appid=${process.env.OW_API_KEY}`);
    const owJson = await owResp.json();
    // normalize
    const normalized = {
      lat: parseFloat(lat),
      lon: parseFloat(lon),
      source: 'openweather',
      timestamp: new Date().toISOString(),
      pm25: owJson.list?.[0]?.components?.pm2_5 ?? null,
      pm10: owJson.list?.[0]?.components?.pm10 ?? null,
      o3: owJson.list?.[0]?.components?.o3 ?? null,
      no2: owJson.list?.[0]?.components?.no2 ?? null,
      aqi: owJson.list?.[0]?.main?.aqi ?? null,
      raw_payload: owJson
    };

    // 3) write to supabase
    const { data, error } = await supabaseAdmin.from('air_reads').insert([normalized]).select();
    return res.status(200).json(data[0]);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'air fetch failed' });
  }
}

/pages/api/llm/reflection.js (pseudocode)

import fetch from 'node-fetch';
export default async function handler(req, res) {
  const { note, pm25, aqi, sensitivity } = req.body;
  const systemPrompt = `SYSTEM PROMPT TEXT...`; // as above
  const userPrompt = `User: note="${note}", pm25=${pm25}, aqi=${aqi}, sensitivity=${JSON.stringify(sensitivity)}`;
  try {
    const llmResp = await fetch(process.env.OPENROUTER_ENDPOINT, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ prompt: systemPrompt + "\n\n" + userPrompt, max_tokens: 200 })
    });
    const json = await llmResp.json();
    // parse expected JSON from text; implement robust parsing (try JSON.parse, else fallback to regex)
    const parsed = safeParseLLM(json);
    return res.status(200).json(parsed);
  } catch (err) {
    return res.status(500).json({ error: 'LLM failed' });
  }
}


⸻

12) Frontend components & UI notes (developer tasks)

Core components
	•	RiskCard — primary visual, color & emoji, pollutant numbers, one-sentence reason, CTA.
	•	ProfileToggles — set sensitivity profile (persist).
	•	SymptomForm — text area, severity slider, submit button.
	•	LLMResponseCard — shows JSON fields in UI.
	•	TimelineChart — Chart.js combining lines & bars.
	•	SavedPlacesList — small list & check button.
	•	CrisisModal — large modal with contact numbers & links.
	•	BottomNav — mobile nav for Dashboard, Log, Timeline, Profile.

Styling
	•	Tailwind utility classes; soft palette (muted teal/blue), large touch targets.
	•	Mobile first: max content width 420px; bottom nav fixed.

Accessibility
	•	ARIA labels, keyboard focus, color contrast, skip links.

⸻

13) Error handling, fallbacks & resilience
	•	Air API fails: use cached DB row. If none, show demo seeding data with “demo data” label.
	•	LLM fails / timeouts: serve canned responses mapped by severity & AQI range (prepopulate tips table).
	•	Rate limits: detect 429 responses; fallback to cached or canned responses and show a small banner “Live API limit reached — showing cached data”.
	•	Parsing LLM: parse safely — accept text that contains JSON; if parsing fails, use fallback templates.

⸻

14) Security & privacy considerations
	•	Secrets: store OW_API_KEY, AIRNOW_KEY, OPENROUTER_KEY, MAPS_KEY in environment variables (Vercel).
	•	No PII by default: app design defaults to anonymous usage; only store user_id if user chooses to register. Provide UI for deleting data.
	•	Data encryption: Supabase handles at rest; enforce HTTPS.
	•	HIPAA: Don’t claim HIPAA compliance for MVP. If you plan to connect to clinical systems, plan for HIPAA compliance later (business associate agreement, secure hosting, audit logs).
	•	Consent: Show a short privacy modal at first launch: “Data stored: symptoms & timestamps; We do not store identifying data unless you opt in.”

⸻

15) Testing strategy
	•	Unit tests: for threshold logic, normalization functions, API wrappers.
	•	Integration tests: Next.js API routes (mock external APIs), DB writes to Supabase test instance.
	•	E2E test: Cypress/Playwright walkthrough: landing → profile → log symptom → LLM response → timeline.
	•	Manual tests: Offline demo, cached mode, emergency flow, rate limit simulation.

⸻

16) Monitoring & observability
	•	Frontend: Sentry (optional) for runtime errors; simple console logs for hack.
	•	Backend logs: Next.js logs for API routes; Supabase logs for DB.
	•	LLM usage metrics: track LLM call counts and latency in a simple DB metrics table.
	•	Alerting: simple Slack/Discord webhook on critical errors (optional).

⸻

17) Deployment & CI
	•	Repo: GitHub (feature branch → main)
	•	CI: GitHub Actions — run lint & unit tests on PR; optional deploy preview to Vercel preview urls.
	•	Environments: .env.local for dev; Vercel env vars for production.
	•	Secrets list (env var names)
	•	NEXT_PUBLIC_SUPABASE_URL
	•	SUPABASE_SERVICE_KEY (server only)
	•	OPENROUTER_API_KEY
	•	OW_API_KEY (OpenWeather)
	•	AIRNOW_API_KEY (optional)
	•	GEOCODE_API_KEY (OpenCage/Google)
	•	SENTRY_DSN (optional)

⸻

18) Build plan (12-hour developer schedule — actionable tasks)

This is a developer task list you can assign, not a promise of delivery by assistant.

Hour 0–0.5 — Repo + infra
	•	Initialize Next.js + Tailwind; push repo; create Supabase project & run SQL.
	•	Seed tips & resources with campus info & canned tips.

Hour 0.5–2.5 — Air API + Dashboard
	•	Implement /api/air route (OpenWeather + caching).
	•	Build RiskCard UI + geolocation; integrate fetch.

Hour 2.5–4 — Profile & thresholds
	•	Profile toggles UI; threshold logic; persist to Supabase.

Hour 4–6 — Symptom form + LLM
	•	Implement SymptomForm UI & /api/llm/reflection route.
	•	Hook submit → save to symptoms → show LLM response.

Hour 6–8 — Timeline
	•	Query air_reads + symptoms; implement Chart.js timeline with seeded data.

Hour 8–10 — Resource UI + Crisis
	•	Implement resources page & CrisisModal + bottom nav.

Hour 10–11.5 — Polish & accessibility
	•	Styling, mobile tweaks, small animations, ARIA attributes.

Hour 11.5–12 — Demo prep
	•	Seed demo user & data, test offline fallback, rehearse demo flow, prepare Devpost video assets.

⸻

19) Team roles & task assignments (example)
	•	Frontend dev (1): Next.js pages, components, styling, chart integration.
	•	Backend dev / API (1): Next.js API routes, Supabase interactions, caching, LLM proxy.
	•	Designer / Demo (0.5): Tailwind theme, icons, demo script, deploy page.

⸻

20) Acceptance criteria summary (for hackathon demo)
	•	Live dashboard shows air data for demo coordinates and appropriate status.
	•	Sensitivity toggles change status thresholds and persist.
	•	Symptom entry returns LLM JSON and is saved.
	•	Timeline displays correlation visually with seeded data.
	•	Crisis button visible and functional.
	•	App accessible on phone via Vercel link and visually polished.

⸻

21) Appendix — LLM prompt templates & canned fallback mapping

Emergency regex (important)

/(can't breathe|cannot breathe|chest pain|chest tight|faint|passing out|severe shortness of breath|call 911|call emergency)/i

LLM JSON prompt example

SYSTEM: You are a concise, empathetic, safety-first health assistant. NEVER give a medical diagnosis. If the input text indicates an emergency (e.g., 'can't breathe', 'chest pain'), respond with severity:'high' and an instruction to seek immediate medical attention. Return only valid JSON with keys: summary, action, severity.

USER: note="I've been coughing and my chest feels tight since this morning", pm25=85, aqi=3, sensitivity={"asthma":true}

Canned fallback logic (sample)
	•	If AQI category is Good & severity slider ≤2 → summary: "Mild symptoms; monitor", action: "Rest & hydrate", severity: "low"
	•	If AQI Moderate & severity ≥3 or asthma true & severity≥2 → summary: "Symptoms may be exposure-related", action: "Avoid outdoor exercise, use inhaler if prescribed", severity: "moderate"
	•	If emergency regex hit → summary: "This may be an emergency", action: "Seek immediate medical attention or call emergency number", severity: "high"

⸻

22) Final notes & immediate next steps (developer checklist)
	•	Create Supabase project, run SQL schema, seed tips + resources.
	•	Create Vercel project & set env vars (list above).
	•	Implement /api/air with caching layer and test with a few lat/lon coordinates (e.g., campus lat/lon).
	•	Implement simple UI: Dashboard + Profile + SymptomForm + Crisis button.
	•	Implement /api/llm/reflection using OpenRouter key; test prompt with sample notes; save to DB.
	•	Seed timeline data to show correlation during demo.
	•	Prepare one offline demo recording as backup.

⸻
